---
layout: post
title: "PW‘s Reading S01E01：Long Names Are Long"
categories: readAndThink
---



## 阅读与思考S01E01

### 1. [设计SSD友好的应用](http://www.infoq.com/cn/articles/design-ssd-friendly-application)

SSD的一个**存储单元**上最多只能进行10万次写操作，难道SSD寿命会很短？当然不是，SSD内部用**垃圾块收集**来保证后续写操作能够快速分配到可用的块，以及**损耗均衡**的机制来平衡每个块的擦除次数。

用SSD替换HDD，虽然能提升不少性能，但要发挥更高的性能，需要作一些**针对性的优化**，你需要知道它与HDD的区别，结构与特性有何不同，其中**擦除**特性是需要重点了解的。

现在常用的数据库，是对HDD友好的，那么我们要做哪些Action才能使数据库是对SSD友好的呢？ 数据结构？线程？如果又有一种新的性能更高的硬件，我们是否又需要重复这一过程？当然，根据**成本优化理论**，就算再重复一遍，也是非常值得的。

### 2. [变化驱动：正交设计](http://www.jianshu.com/p/d127b8afc8cb)

随着业务的不断发展，系统也会趋于越来越复杂，如何应对软件复杂性，是一个恒久不变的话题。对系统进行合理的**拆分**，运用**模块化设计**，是一个非常有效的应对软件复杂性的手段。个人感觉，拆分过程中最不易把握的是**模块粒度**，这个需要长时间的“训练”，就业务系统来说，对业务要有一定的全局观并且需要深入了解业务的本质，成为一个**领域专家**。

作者也就个人经验，就如何拆分模块，模块之间如何交互，提出了一些自己的见解，值得深思与学习。



### 3. [分布式系统事务一致性解决方案](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)

我非常讨厌分布式事务，除非金融等行业，我真的不想用什么**两阶段提交协议**来实现分布式事务，太复杂，对性能有影响。一般场景下，可以容忍短暂的不一致，我都倾向于**最终一致性**（BASE）。而文中提到的**本地消息表**是一个不错的方案，事务消息的**half message**设计也是非常经典，阿里基本上是用这个技术来实施分布式事务的。

另外，一些弱依赖的RPC调用失败，我们也可以用**重试补偿**的方式来达到**自愈**的目的。目前，比如我们可以设计基于可靠性比较高的日志，又或者notify去支持一个不区分应用的topic，来达到RPC调用自愈的系统，并配套提供监控、报警等功能。



### 4. [Long Names Are Long](http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=email)

中文版：http://yemengying.com/2016/06/25/cleanCode4naming/

一般的代码review都停留在常规的review，而忽视了**代码可读性（readability）**层面的review，作者就代码可读性的最基本也是最重要的一点：**命名**，提出了一些非常有用的建议与原则。命名的两个核心目标：**清晰（clear）**、**精确（precise）**。要清楚的知道这个命名与什么有关，与什么无关。

作者提到命名不能太长，确实，太长的命名会变得晦涩难懂，不过我觉得长命名是一个比较好的中间状态，当然它是一种臭味，需要加以分析，**为什么要用这么长的命名才能把要说的事情说清楚**，然后再去重构命名。

当一个人说道“码代码最纠结的就是命名了，每次都要想很久...”时，至少能看出这是一个比较**负责任**的人，他（她）的代码质量应当不错。**重构命名**，是一个非常好的习惯，可以培养你对命名的感觉（臭味或香味）。在反复的对一个命名进行重构时，你会发现你的理解越来越到位，甚至可能可以帮助你的抽象。

最近，我也在做大团队的代码质量提升方面的工作，这篇文章对我帮助很大，作者的一些原则完全可以借过来实施。赞作者！！！



### 5. [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

**索引即是数据结构**，我们都知道一般情况下采用[B+ tree](https://en.wikipedia.org/wiki/B%2B_tree)数据结构，但是为什么是这种数据结构呢，红黑树不行么？  
  
文章从内存和磁盘存取原理，解释了为什么采用B+Tree，总原则是**尽量减少查找过程中磁盘I/O的存取次数**；这就需要充分了解存储器原理，结合磁盘预读、局部性等原理，去考量如何设计一个节点的大小等I/O相关的细节，这些设计细节值得学习。  

对于一名业务开发，数据库几乎是每天要碰的，我们可以不了解数据库设计原理（最好能），但至少要深入了解数据库索引、连接池等相关的知识，这对你的应用性能至关重要，负责任的程序员应该对你写的sql进行**索引review**（比如mysql中explain一下）。


### 6. [微博众筹的架构设计](http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653547384&idx=1&sn=c2a667af2077eddfa9b1a06b67c0f33c)




### 7. [Elasticsearch 架构以及源码概览](http://mp.weixin.qq.com/s?__biz=MzA4NjgwMDQ0OA==&mid=2652445487&idx=1&sn=fb99fac1db2ad8120e98f00165323b2a)

### 8. [StackOverflow: 你没见过的七个最好的Java答案](http://www.rowkey.me/blog/2016/08/03/so-java-7-answers/)
